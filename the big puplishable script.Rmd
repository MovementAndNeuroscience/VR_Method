---
title: "Data Analyses for Virtual Reality and Computer Screen Experiments"
author: "Rasmus Ahmt & Marta Topor"
date: "2023-3-31"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  eval = TRUE,
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
library(tidyverse)
library(ggpubr)
library(rstatix)
library(rmarkdown)
library(multcomp)
library(dplyr)
library(ggstance)
library(emmeans)
library(car)
library(broom)

#set R language to English
Sys.setenv(lang = "en_UK")
```
  
# Introduction 
This document presents the output for data analyses used in a methodological article titled: "Developing Virtual Reality and Computer Screen Experiments One to One Using Selective Attention as a Case Study".  

  
```{r tools}
## The tools needed for analyses will be deposited here

## First, we need to consider that we are working with .csv files that were recorded with a semicolon separated settings rather than comma separated settings. This means that numerical decimal places are separated with a comma rather than a dot. Therefore, the commas in numbers will have to be replaced with dots so that they can be classed as numerical values.   
   
## The following function is needed (sourced from https://stackoverflow.com/questions/59380129/changing-to-within-a-function-in-r )
## Change "," to "."
convert_number <- function(x) {
  x <- as.character(x)
  x <- gsub(
    pattern = ",",
    replacement = ".",
    x = x,
    fixed = TRUE
  )
  x <- as.numeric(x)
  return(x)
}
##
```

```{r import data for VR}
# This section of the script is responsible for importing data from the designated folder.
# The data is imported in a long and tidy format is to ensure that the data can be easily manipulated and analyzed using tidyverse.

#The task that the data were recorded for is a multisensory selective attention task. There are two conditions - VR and PC. The data for these conditons are kept in different folders. 


#_______________VR__________________________#
# Import all data for the VR condition.
# The VR folder has then separate folders for each participants. These hold .csv files, semicolon separated, with output for each participant. 


# Set working directory
setwd("/Users/rasmus/Desktop/VR_Method")

# Look in the directory and search for CSV files.
myList <- list.dirs(path = "/Users/rasmus/Desktop/VR_Method/RAW VR")[-1] #not quite good to name a list "list" because it might get confusing in R at some point, so I changed it to myList, [-1] because the first position listed is the main folder which is not needed here 


#Create and empty data frame to extract the data
#The data frame includes columns for mean RTs, RT SDs, median RTs and Accuracy including correct and missed trials. These are extracted for three multisensory modalities (auditory, visual and audio-visual) and three congruency types (congruent, incongruent and neutral). So there are 9 types of trials (3x3) and each type of trial has mean RT, RT SD and Accuracy extracted (9 x 3) resulting in 46 data columns. For Reaction time data - only correct trials are used

DF <- data.frame(matrix(nrow = length(myList), ncol=46))
colnames(DF) <- c("id", "incongruent_and_audio_RT", "incongruent_and_audio_RT_sd", "incongruent_and_audio_RT_md", "Correct_answers_incongruent_and_audio", "missed_answers_incongruent_and_audio", "incongruent_and_visual_RT", "incongruent_and_visual_RT_sd", "incongruent_and_visual_RT_md", "Correct_answers_incongruent_and_visual", "missed_answers_incongruent_and_visual", "incongruent_and_audio.visual_RT", "incongruent_and_audio.visual_RT_sd", "incongruent_and_audio.visual_RT_md", "Correct_answers_incongruent_and_audio.visual", "missed_answers_incongruent_and_audio.visual", "congruent_and_audio_RT", "congruent_and_audio_RT_sd", "congruent_and_audio_RT_md", "Correct_answers_congruent_and_audio", "missed_answers_congruent_and_audio", "congruent_and_visual_RT", "congruent_and_visual_RT_sd", "congruent_and_visual_RT_md", "Correct_answers_congruent_and_visual", "missed_answers_congruent_and_visual", "congruent_and_audio.visual_RT", "congruent_and_audio.visual_RT_sd", "congruent_and_audio.visual_RT_md", "Correct_answers_congruent_and_audio.visual", "missed_answers_congruent_and_audio.visual", "neutral_and_audio_RT", "neutral_and_audio_RT_sd", "neutral_and_audio_RT_md", "Correct_answers_neutral_and_audio", "missed_answers_neutral_and_audio", "neutral_and_visual_RT",   "neutral_and_visual_RT_sd", "neutral_and_visual_RT_md", "Correct_answers_neutral_and_visual", "missed_answers_neutral_and_visual", "neutral_and_audio.visual_RT", "neutral_and_audio.visual_RT_sd", "neutral_and_audio.visual_RT_md", "Correct_answers_neutral_and_audio.visual", "missed_answers_neutral_and_audio.visual")



#Loop through the files to extract data for the DF
# "i" represents the current participant and is set to loop through all files in the directory.
# It is set to loop from 1 to the length of the list of files in our directory.


for (i in 1:length(myList))
{
  setwd(myList[i])
  myData_base <- read_csv2(list.files(), col_select = c(1:14), col_types = c("nnnnnnnnnnccnc"))  #import base data per participant
  #there are VR specific columns which do not correspond to the columns recorded in the PC task so these are not imported 
  #the data are in the semicolon separated file with a mix of numbers and characters in one columns so it's difficult to import them all as numeric values 
  #the solution above works but it forces false numbers to replace characters. These rows must be removed using the code below:
  myData <- myData_base %>% filter(`Answers Block1` %in% c("Correct", "Incorrect","None"))
  #lastly, the column names are not as neat as when the data are imported with the read.csv function so they will be replaced
  setwd(myList[i])
  myData_header <- read.csv2(list.files())
  header <- colnames(myData_header[1:14])
  colnames(myData) <- header 
  
  # Extract Participants number
  DF$id[i] <- substr(myList[i], 60, 65) # take characters 60-65 from the name of the folder
  
  ## Extract Data for Incongruent Trials
  # Incongruent_and_audio
  incongruent_and_audio1 <-
    subset(
      myData,
      Answer.Codes.Block1 == "1" &
        Presented.Condition.Block1 == "Incongruent" &
        Distractor.Modality.Block1 == "audio"
    )

  if (is_empty(incongruent_and_audio1$ReactionTime.Block1) == TRUE) { 
    DF$incongruent_and_audio_RT[i] <- NA # these should be NAs rather than 0, because RT of 0 is numerically misleading (i.e. it seems as though people responded in 0 seconds - this skews means etc later on)
    DF$incongruent_and_audio_RT_sd[i] <- NA
    DF$incongruent_and_audio_RT_md[i] <- NA
  } else{
    DF$incongruent_and_audio_RT[i] <- mean(incongruent_and_audio1$ReactionTime.Block1, na.rm = TRUE) #here na.rm = TRUE is important because otherwise we will get an NA for the participant
    DF$incongruent_and_audio_RT_sd[i] <- sd(incongruent_and_audio1$ReactionTime.Block1, na.rm = TRUE)
    DF$incongruent_and_audio_RT_md[i] <- median(incongruent_and_audio1$ReactionTime.Block1, na.rm = TRUE)
  }
  if (is_empty(incongruent_and_audio1$ReactionTime.Block1) == TRUE) {
    DF$Correct_answers_incongruent_and_audio[i] <- 0
  } else{
    DF$Correct_answers_incongruent_and_audio[i] <-
      length(incongruent_and_audio1$Answers.Block1) 
  }
  DF$missed_answers_incongruent_and_audio[i] <- length(myData$Answer.Codes.Block1[myData$Answer.Codes.Block1 == 0 & myData$Presented.Condition.Block1 == "Incongruent" & myData$Distractor.Modality.Block1 == "audio"])
  
  # incongruent_and_visual
  incongruent_and_visual1 <-
    subset(
      myData,
      Answer.Codes.Block1 == "1" &
        Presented.Condition.Block1 == "Incongruent" &
        Distractor.Modality.Block1 == "visual"
    )
  
  if (is_empty(incongruent_and_visual1$ReactionTime.Block1) == TRUE) {
    DF$incongruent_and_visual_RT[i] <- NA
    DF$incongruent_and_visual_RT_sd[i] <- NA
    DF$incongruent_and_visual_RT_md[i] <- NA
  } else{
    DF$incongruent_and_visual_RT[i] <- mean(incongruent_and_visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$incongruent_and_visual_RT_sd[i] <- sd(incongruent_and_visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$incongruent_and_visual_RT_md[i] <- median(incongruent_and_visual1$ReactionTime.Block1, na.rm = TRUE)
  }
  if (is_empty(incongruent_and_visual1$ReactionTime.Block1) == TRUE) {
    DF$Correct_answers_incongruent_and_visual[i] <- 0
  } else{
    DF$Correct_answers_incongruent_and_visual[i] <-
      length(incongruent_and_visual1$Answers.Block1)
  }
  DF$missed_answers_incongruent_and_visual[i] <- length(myData$Answer.Codes.Block1[myData$Answer.Codes.Block1 == 0 & myData$Presented.Condition.Block1 == "Incongruent" & myData$Distractor.Modality.Block1 == "visual"])
  
  # incongruent_and_visual and audio
  incongruent_and_audio.visual1 <-
    subset(
      myData,
      Answer.Codes.Block1 == "1" &
        Presented.Condition.Block1 == "Incongruent" &
        Distractor.Modality.Block1 == "audio visual"
    )

  if (is_empty(incongruent_and_audio.visual1$ReactionTime.Block1) == TRUE) {
    DF$incongruent_and_audio.visual_RT[i] <- NA
    DF$incongruent_and_audio.visual_RT_sd[i] <- NA
    DF$incongruent_and_audio.visual_RT_md[i] <- NA
  } else{
    DF$incongruent_and_audio.visual_RT[i] <-
      mean(incongruent_and_audio.visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$incongruent_and_audio.visual_RT_sd[i] <-
      sd(incongruent_and_audio.visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$incongruent_and_audio.visual_RT_md[i] <-
      median(incongruent_and_audio.visual1$ReactionTime.Block1, na.rm = TRUE)
  }
  if (is_empty(incongruent_and_audio.visual1$ReactionTime.Block1) == TRUE) {
    DF$Correct_answers_incongruent_and_audio.visual[i] <- 0
  } else{
    DF$Correct_answers_incongruent_and_audio.visual[i] <-
      length(incongruent_and_audio.visual1$Answers.Block1)
  }
  DF$missed_answers_incongruent_and_audio.visual[i] <- length(myData$Answer.Codes.Block1[myData$Answer.Codes.Block1 == 0 & myData$Presented.Condition.Block1 == "Incongruent" & myData$Distractor.Modality.Block1 == "audio visual"])
  
  ## Extract Data for Congruent Trials
  # congruent_and_audio
  congruent_and_audio1 <-
    subset(
      myData,
      Answer.Codes.Block1 == "1" &
        Presented.Condition.Block1 == "Congruent" &
        Distractor.Modality.Block1 == "audio"
    )

  if (is_empty(congruent_and_audio1$ReactionTime.Block1) == TRUE) {
    DF$congruent_and_audio_RT[i] <- NA
    DF$congruent_and_audio_RT_sd[i] <- NA
    DF$congruent_and_audio_RT_md[i] <- NA
  } else{
    DF$congruent_and_audio_RT[i] <- mean(congruent_and_audio1$ReactionTime.Block1, na.rm = TRUE)
    DF$congruent_and_audio_RT_sd[i] <- sd(congruent_and_audio1$ReactionTime.Block1, na.rm = TRUE)
    DF$congruent_and_audio_RT_md[i] <- median(congruent_and_audio1$ReactionTime.Block1, na.rm = TRUE)
  }
  if (is_empty(congruent_and_audio1$ReactionTime.Block1) == TRUE) {
    DF$Correct_answers_congruent_and_audio[i] <- 0
  } else{
    DF$Correct_answers_congruent_and_audio[i] <-
      length(congruent_and_audio1$Answers.Block1)
  }
  DF$missed_answers_congruent_and_audio[i] <- length(myData$Answer.Codes.Block1[myData$Answer.Codes.Block1 == 0 & myData$Presented.Condition.Block1 == "Congruent" & myData$Distractor.Modality.Block1 == "audio"])
  
  # congruent_and_visual
  congruent_and_visual1 <-
    subset(
      myData,
      Answer.Codes.Block1 == "1" &
        Presented.Condition.Block1 == "Congruent" &
        Distractor.Modality.Block1 == "visual"
    )

  if (is_empty(congruent_and_visual1$ReactionTime.Block1) == TRUE) {
    DF$congruent_and_visual_RT[i] <- NA
    DF$congruent_and_visual_RT_sd[i] <- NA
    DF$congruent_and_visual_RT_md[i] <- NA
  } else{
    DF$congruent_and_visual_RT[i] <- mean(congruent_and_visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$congruent_and_visual_RT_sd[i] <- sd(congruent_and_visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$congruent_and_visual_RT_md[i] <- median(congruent_and_visual1$ReactionTime.Block1, na.rm = TRUE)
  }
  if (is_empty(congruent_and_visual1$ReactionTime.Block1) == TRUE) {
    DF$Correct_answers_congruent_and_visual[i] <- 0
  } else{
    DF$Correct_answers_congruent_and_visual[i] <-
      length(congruent_and_visual1$Answers.Block1)
  }
  DF$missed_answers_congruent_and_visual[i] <- length(myData$Answer.Codes.Block1[myData$Answer.Codes.Block1 == 0 & myData$Presented.Condition.Block1 == "Congruent" & myData$Distractor.Modality.Block1 == "visual"])
  
  # congruent_and_visual and audio
  congruent_and_audio.visual1 <-
    subset(
      myData,
      Answer.Codes.Block1 == "1" &
        Presented.Condition.Block1 == "Congruent" &
        Distractor.Modality.Block1 == "audio visual"
    )

  if (is_empty(congruent_and_audio.visual1$ReactionTime.Block1) == TRUE) {
    DF$congruent_and_audio.visual_RT[i] <- NA
    DF$congruent_and_audio.visual_RT_sd[i] <- NA
    DF$congruent_and_audio.visual_RT_md[i] <- NA
  } else{
    DF$congruent_and_audio.visual_RT[i] <- mean(congruent_and_audio.visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$congruent_and_audio.visual_RT_sd[i] <- sd(congruent_and_audio.visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$congruent_and_audio.visual_RT_md[i] <- median(congruent_and_audio.visual1$ReactionTime.Block1, na.rm = TRUE)
  }
  if (is_empty(congruent_and_audio.visual1$ReactionTime.Block1) == TRUE) {
    DF$Correct_answers_congruent_and_audio.visual[i] <- 0
  } else{
    DF$Correct_answers_congruent_and_audio.visual[i] <-
      length(congruent_and_audio.visual1$Answers.Block1)
  }
  DF$missed_answers_congruent_and_audio.visual[i] <- length(myData$Answer.Codes.Block1[myData$Answer.Codes.Block1 == 0 & myData$Presented.Condition.Block1 == "Congruent" & myData$Distractor.Modality.Block1 == "audio visual"])
  
  ## Extract Data for Neutral trials
  # neutral_and_audio
  neutral_and_audio1 <-
    subset(
      myData,
      Answer.Codes.Block1 == "1" &
        Presented.Condition.Block1 == "Neutral" &
        Distractor.Modality.Block1 == "audio"
    )

  if (is_empty(neutral_and_audio1$ReactionTime.Block1) == TRUE) {
    DF$neutral_and_audio_RT[i] <- NA
    DF$neutral_and_audio_RT_sd[i] <- NA
    DF$neutral_and_audio_RT_md[i] <- NA
  } else{
    DF$neutral_and_audio_RT[i] <- mean(neutral_and_audio1$ReactionTime.Block1, na.rm = TRUE)
    DF$neutral_and_audio_RT_sd[i] <- sd(neutral_and_audio1$ReactionTime.Block1, na.rm = TRUE)
    DF$neutral_and_audio_RT_md[i] <- median(neutral_and_audio1$ReactionTime.Block1, na.rm = TRUE)
  }
  if (is_empty(neutral_and_audio1$ReactionTime.Block1) == TRUE) {
    DF$Correct_answers_neutral_and_audio[i] <- 0
  } else{
    DF$Correct_answers_neutral_and_audio[i] <-
      length(neutral_and_audio1$Answers.Block1)
  }
  DF$missed_answers_neutral_and_audio[i] <- length(myData$Answer.Codes.Block1[myData$Answer.Codes.Block1 == 0 & myData$Presented.Condition.Block1 == "Neutral" & myData$Distractor.Modality.Block1 == "audio"])
  
  # neutral_and_visual
  neutral_and_visual1 <-
    subset(
      myData,
      Answer.Codes.Block1 == "1" &
        Presented.Condition.Block1 == "Neutral" &
        Distractor.Modality.Block1 == "visual"
    )

  if (is_empty(neutral_and_visual1$ReactionTime.Block1) == TRUE) {
    DF$neutral_and_visual_RT[i] <- NA
    DF$neutral_and_visual_RT_sd[i] <- NA
    DF$neutral_and_visual_RT_md[i] <- NA
  } else{
    DF$neutral_and_visual_RT[i] <- mean(neutral_and_visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$neutral_and_visual_RT_sd[i] <- sd(neutral_and_visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$neutral_and_visual_RT_md[i] <- median(neutral_and_visual1$ReactionTime.Block1, na.rm = TRUE)
  }
  if (is_empty(neutral_and_visual1$ReactionTime.Block1) == TRUE) {
    DF$Correct_answers_neutral_and_visual[i] <- 0
  } else{
    DF$Correct_answers_neutral_and_visual[i] <-
      length(neutral_and_visual1$Answers.Block1)
  }
  DF$missed_answers_neutral_and_visual[i] <- length(myData$Answer.Codes.Block1[myData$Answer.Codes.Block1 == 0 & myData$Presented.Condition.Block1 == "Neutral" & myData$Distractor.Modality.Block1 == "visual"])
  
  # neutral_and_visual and audio
  neutral_and_audio.visual1 <-
    subset(
      myData,
      Answer.Codes.Block1 == "1" &
        Presented.Condition.Block1 == "Neutral" &
        Distractor.Modality.Block1 == "audio visual"
    )

  if (is_empty(neutral_and_audio.visual1$ReactionTime.Block1) == TRUE) {
    DF$neutral_and_audio.visual_RT[i] <- NA
    DF$neutral_and_audio.visual_RT_sd[i] <- NA
    DF$neutral_and_audio.visual_RT_md[i] <- NA
  } else{
    DF$neutral_and_audio.visual_RT[i] <- mean(neutral_and_audio.visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$neutral_and_audio.visual_RT_sd[i] <- sd(neutral_and_audio.visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$neutral_and_audio.visual_RT_md[i] <- median(neutral_and_audio.visual1$ReactionTime.Block1, na.rm = TRUE)
  }
  if (is_empty(neutral_and_audio.visual1$ReactionTime.Block1) == TRUE) {
    DF$Correct_answers_neutral_and_audio.visual[i] = 0
  } else{
    DF$Correct_answers_neutral_and_audio.visual[i] <-
      length(neutral_and_audio.visual1$Answers.Block1)
  }
  DF$missed_answers_neutral_and_audio.visual[i] <- length(myData$Answer.Codes.Block1[myData$Answer.Codes.Block1 == 0 & myData$Presented.Condition.Block1 == "Neutral" & myData$Distractor.Modality.Block1 == "audio visual"])
  
#clean myData and myData base
rm(myData, myData_base, myData_header)
  
}
# A temporary data set to hold the information from the VR data, so we can reuse this loop for the PC files.
VR_not_done <- DF

```

```{r import data for PC}

#Here we reuse the DF and myList structures made previously but replace all values with NA just to make sure no previous values remain
DF[,] <- NA
myList <- NA
#We will also make new structures for the different types of conditions so these need to be removed first to make sure we are not inputing old data by accident
rm(congruent_and_audio.visual1, congruent_and_audio1, congruent_and_visual1, incongruent_and_audio.visual1, incongruent_and_audio1, incongruent_and_visual1, neutral_and_audio.visual1, neutral_and_audio1, neutral_and_visual1)

#_______________PC___________________________#
# Import all the PC data.
# In the PC folder, there is one .csv file, semicolon separated, for each participant. They will be imported into two separate data frames.

# Set the working directory to the PC folder
setwd("/Users/rasmus/Desktop/VR_Method/RAW PC")

# Look in the directory and search for CSV files.
myList <- list.files(pattern = ".csv", recursive = TRUE) #not quite good to name a list "list" becaude it might get confusinng in R at some point, so I changed it to myList 


#Loop through the files to extract data for the DF
# "i" represents the current participant and is set to loop through all files in the directory.
# It is set to loop from 1 to the length of the list of files in our directory.


for (i in 1:length(myList))
{
  myData_base <- read.csv(myList[i], sep = ";", stringsAsFactors = FALSE) #import base data per participant where all columns will be character values
  #here the issue with importing as semicolon separated files is not as problematic as in the case of the VR files so an easier solution is implemented below
  myData <- myData_base %>% mutate_if(is.character, as.numeric) # make all values numeric 
  myData$Presented.Condition.Block1 <- myData_base$Presented.Condition.Block1 #replace the character columns with the base data 
  myData$Answers.Block1 <- myData_base$Answers.Block1 #replace the character columns with the base data
  myData$Distractor.Modality.Block1 <- myData_base$Distractor.Modality.Block1 #replace the character columns with the base data
  
  # Extract Participants number
  DF$id[i] <- substr(myList[i], 1, 5) # take characters 1-5 from the name of the file
  
  ## Extract Data for Incongruent Trials
  # Incongruent_and_audio
  incongruent_and_audio1 <-
    subset(
      myData,
      Answer.Codes.Block1 == "1" &
        Presented.Condition.Block1 == "Incongruent" &
        Distractor.Modality.Block1 == "audio"
    )

  if (is_empty(incongruent_and_audio1$ReactionTime.Block1) == TRUE) { 
    DF$incongruent_and_audio_RT[i] <- NA # these should be NAs rather than 0, because RT of 0 is numerically misleading (i.e. it seems as though people responded in 0 seconds - this skews means etc later on)
    DF$incongruent_and_audio_RT_sd[i] <- NA
    DF$incongruent_and_audio_RT_md[i] <- NA
  } else{
    DF$incongruent_and_audio_RT[i] <- mean(incongruent_and_audio1$ReactionTime.Block1, na.rm = TRUE)
    DF$incongruent_and_audio_RT_sd[i] <- sd(incongruent_and_audio1$ReactionTime.Block1, na.rm = TRUE)
    DF$incongruent_and_audio_RT_md[i] <- median(incongruent_and_audio1$ReactionTime.Block1, na.rm = TRUE)
  }
  if (is_empty(incongruent_and_audio1$ReactionTime.Block1) == TRUE) {
    DF$Correct_answers_incongruent_and_audio[i] <- 0
  } else{
    DF$Correct_answers_incongruent_and_audio[i] <-
      length(incongruent_and_audio1$Answers.Block1)
  }
  DF$missed_answers_incongruent_and_audio[i] <- length(myData$Answer.Codes.Block1[myData$Answer.Codes.Block1 == 0 & myData$Presented.Condition.Block1 == "Incongruent" & myData$Distractor.Modality.Block1 == "audio"])
  
  # incongruent_and_visual
  incongruent_and_visual1 <-
    subset(
      myData,
      Answer.Codes.Block1 == "1" &
        Presented.Condition.Block1 == "Incongruent" &
        Distractor.Modality.Block1 == "visual"
    )
  
  if (is_empty(incongruent_and_visual1$ReactionTime.Block1) == TRUE) {
    DF$incongruent_and_visual_RT[i] <- NA
    DF$incongruent_and_visual_RT_sd[i] <- NA
    DF$incongruent_and_visual_RT_md[i] <- NA
  } else{
    DF$incongruent_and_visual_RT[i] <- mean(incongruent_and_visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$incongruent_and_visual_RT_sd[i] <- sd(incongruent_and_visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$incongruent_and_visual_RT_md[i] <- median(incongruent_and_visual1$ReactionTime.Block1, na.rm = TRUE)
  }
  if (is_empty(incongruent_and_visual1$ReactionTime.Block1) == TRUE) {
    DF$Correct_answers_incongruent_and_visual[i] <- 0
  } else{
    DF$Correct_answers_incongruent_and_visual[i] <-
      length(incongruent_and_visual1$Answers.Block1)
  }
    DF$missed_answers_incongruent_and_visual[i] <- length(myData$Answer.Codes.Block1[myData$Answer.Codes.Block1 == 0 & myData$Presented.Condition.Block1 == "Incongruent" & myData$Distractor.Modality.Block1 == "visual"])
  
  # incongruent_and_visual and audio
  incongruent_and_audio.visual1 <-
    subset(
      myData,
      Answer.Codes.Block1 == "1" &
        Presented.Condition.Block1 == "Incongruent" &
        Distractor.Modality.Block1 == "audio visual"
    )

  if (is_empty(incongruent_and_audio.visual1$ReactionTime.Block1) == TRUE) {
    DF$incongruent_and_audio.visual_RT[i] <- NA
    DF$incongruent_and_audio.visual_RT_sd[i] <- NA
    DF$incongruent_and_audio.visual_RT_md[i] <- NA
  } else{
    DF$incongruent_and_audio.visual_RT[i] <-
      mean(incongruent_and_audio.visual1$ReactionTime.Block1)
    DF$incongruent_and_audio.visual_RT_sd[i] <-
      sd(incongruent_and_audio.visual1$ReactionTime.Block1)
    DF$incongruent_and_audio.visual_RT_md[i] <-
      median(incongruent_and_audio.visual1$ReactionTime.Block1)
  }
  if (is_empty(incongruent_and_audio.visual1$ReactionTime.Block1) == TRUE) {
    DF$Correct_answers_incongruent_and_audio.visual[i] <- 0
  } else{
    DF$Correct_answers_incongruent_and_audio.visual[i] <-
      length(incongruent_and_audio.visual1$Answers.Block1)
  }
  DF$missed_answers_incongruent_and_audio.visual[i] <- length(myData$Answer.Codes.Block1[myData$Answer.Codes.Block1 == 0 & myData$Presented.Condition.Block1 == "Incongruent" & myData$Distractor.Modality.Block1 == "audio visual"])
  
  ## Extract Data for Congruent Trials
  # congruent_and_audio
  congruent_and_audio1 <-
    subset(
      myData,
      Answer.Codes.Block1 == "1" &
        Presented.Condition.Block1 == "Congruent" &
        Distractor.Modality.Block1 == "audio"
    )

  if (is_empty(congruent_and_audio1$ReactionTime.Block1) == TRUE) {
    DF$congruent_and_audio_RT[i] <- NA
    DF$congruent_and_audio_RT_sd[i] <- NA
    DF$congruent_and_audio_RT_md[i] <- NA
  } else{
    DF$congruent_and_audio_RT[i] <- mean(congruent_and_audio1$ReactionTime.Block1, na.rm = TRUE)
    DF$congruent_and_audio_RT_sd[i] <- sd(congruent_and_audio1$ReactionTime.Block1, na.rm = TRUE)
    DF$congruent_and_audio_RT_md[i] <- median(congruent_and_audio1$ReactionTime.Block1, na.rm = TRUE)
  }
  if (is_empty(congruent_and_audio1$ReactionTime.Block1) == TRUE) {
    DF$Correct_answers_congruent_and_audio[i] <- 0
  } else{
    DF$Correct_answers_congruent_and_audio[i] <-
      length(congruent_and_audio1$Answers.Block1)
  }
  DF$missed_answers_congruent_and_audio[i] <- length(myData$Answer.Codes.Block1[myData$Answer.Codes.Block1 == 0 & myData$Presented.Condition.Block1 == "Congruent" & myData$Distractor.Modality.Block1 == "audio"])
  
  # congruent_and_visual
  congruent_and_visual1 <-
    subset(
      myData,
      Answer.Codes.Block1 == "1" &
        Presented.Condition.Block1 == "Congruent" &
        Distractor.Modality.Block1 == "visual"
    )

  
  if (is_empty(congruent_and_visual1$ReactionTime.Block1) == TRUE) {
    DF$congruent_and_visual_RT[i] <- NA
    DF$congruent_and_visual_RT_sd[i] <- NA
    DF$congruent_and_visual_RT_md[i] <- NA
  } else{
    DF$congruent_and_visual_RT[i] <- mean(congruent_and_visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$congruent_and_visual_RT_sd[i] <- sd(congruent_and_visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$congruent_and_visual_RT_md[i] <- median(congruent_and_visual1$ReactionTime.Block1, na.rm = TRUE)
  }
  if (is_empty(congruent_and_visual1$ReactionTime.Block1) == TRUE) {
    DF$Correct_answers_congruent_and_visual[i] <- 0
  } else{
    DF$Correct_answers_congruent_and_visual[i] <-
      length(congruent_and_visual1$Answers.Block1)
  }
  DF$missed_answers_congruent_and_visual[i] <- length(myData$Answer.Codes.Block1[myData$Answer.Codes.Block1 == 0 & myData$Presented.Condition.Block1 == "Congruent" & myData$Distractor.Modality.Block1 == "visual"])
  
  # congruent_and_visual and audio
  congruent_and_audio.visual1 <-
    subset(
      myData,
      Answer.Codes.Block1 == "1" &
        Presented.Condition.Block1 == "Congruent" &
        Distractor.Modality.Block1 == "audio visual"
    )

  if (is_empty(congruent_and_audio.visual1$ReactionTime.Block1) == TRUE) {
    DF$congruent_and_audio.visual_RT[i] <- NA
    DF$congruent_and_audio.visual_RT_sd[i] <- NA
    DF$congruent_and_audio.visual_RT_md[i] <- NA
  } else{
    DF$congruent_and_audio.visual_RT[i] <- mean(congruent_and_audio.visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$congruent_and_audio.visual_RT_sd[i] <- sd(congruent_and_audio.visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$congruent_and_audio.visual_RT_md[i] <- median(congruent_and_audio.visual1$ReactionTime.Block1, na.rm = TRUE)
  }
  if (is_empty(congruent_and_audio.visual1$ReactionTime.Block1) == TRUE) {
    DF$Correct_answers_congruent_and_audio.visual[i] <- 0
  } else{
    DF$Correct_answers_congruent_and_audio.visual[i] <-
      length(congruent_and_audio.visual1$Answers.Block1)
  }
  DF$missed_answers_congruent_and_audio.visual[i] <- length(myData$Answer.Codes.Block1[myData$Answer.Codes.Block1 == 0 & myData$Presented.Condition.Block1 == "Congruent" & myData$Distractor.Modality.Block1 == "audio visual"])
  
  ## Extract Data for Neutral trials
  # neutral_and_audio
  neutral_and_audio1 <-
    subset(
      myData,
      Answer.Codes.Block1 == "1" &
        Presented.Condition.Block1 == "Neutral" &
        Distractor.Modality.Block1 == "audio"
    )

  if (is_empty(neutral_and_audio1$ReactionTime.Block1) == TRUE) {
    DF$neutral_and_audio_RT[i] <- NA
    DF$neutral_and_audio_RT_sd[i] <- NA
    DF$neutral_and_audio_RT_md[i] <- NA
  } else{
    DF$neutral_and_audio_RT[i] <- mean(neutral_and_audio1$ReactionTime.Block1, na.rm = TRUE)
    DF$neutral_and_audio_RT_sd[i] <- sd(neutral_and_audio1$ReactionTime.Block1, na.rm = TRUE)
    DF$neutral_and_audio_RT_md[i] <- median(neutral_and_audio1$ReactionTime.Block1, na.rm = TRUE)
  }
  if (is_empty(neutral_and_audio1$ReactionTime.Block1) == TRUE) {
    DF$Correct_answers_neutral_and_audio[i] <- 0
  } else{
    DF$Correct_answers_neutral_and_audio[i] <-
      length(neutral_and_audio1$Answers.Block1)
  }
  DF$missed_answers_neutral_and_audio[i] <- length(myData$Answer.Codes.Block1[myData$Answer.Codes.Block1 == 0 & myData$Presented.Condition.Block1 == "Neutral" & myData$Distractor.Modality.Block1 == "audio"])
  
  # neutral_and_visual
  neutral_and_visual1 <-
    subset(
      myData,
      Answer.Codes.Block1 == "1" &
        Presented.Condition.Block1 == "Neutral" &
        Distractor.Modality.Block1 == "visual"
    )

  if (is_empty(neutral_and_visual1$ReactionTime.Block1) == TRUE) {
    DF$neutral_and_visual_RT[i] <- NA
    DF$neutral_and_visual_RT_sd[i] <- NA
    DF$neutral_and_visual_RT_md[i] <- NA
  } else{
    DF$neutral_and_visual_RT[i] <- mean(neutral_and_visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$neutral_and_visual_RT_sd[i] <- sd(neutral_and_visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$neutral_and_visual_RT_md[i] <- median(neutral_and_visual1$ReactionTime.Block1, na.rm = TRUE)
  }
  if (is_empty(neutral_and_visual1$ReactionTime.Block1) == TRUE) {
    DF$Correct_answers_neutral_and_visual[i] <- 0
  } else{
    DF$Correct_answers_neutral_and_visual[i] <-
      length(neutral_and_visual1$Answers.Block1)
  }
  DF$missed_answers_neutral_and_visual[i] <- length(myData$Answer.Codes.Block1[myData$Answer.Codes.Block1 == 0 & myData$Presented.Condition.Block1 == "Neutral" & myData$Distractor.Modality.Block1 == "visual"])
  
  # neutral_and_visual and audio
  neutral_and_audio.visual1 <-
    subset(
      myData,
      Answer.Codes.Block1 == "1" &
        Presented.Condition.Block1 == "Neutral" &
        Distractor.Modality.Block1 == "audio visual"
    )

  if (is_empty(neutral_and_audio.visual1$ReactionTime.Block1) == TRUE) {
    DF$neutral_and_audio.visual_RT[i] <- NA
    DF$neutral_and_audio.visual_RT_sd[i] <- NA
    DF$neutral_and_audio.visual_RT_md[i] <- NA
  } else{
    DF$neutral_and_audio.visual_RT[i] <- mean(neutral_and_audio.visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$neutral_and_audio.visual_RT_sd[i] <- sd(neutral_and_audio.visual1$ReactionTime.Block1, na.rm = TRUE)
    DF$neutral_and_audio.visual_RT_md[i] <- median(neutral_and_audio.visual1$ReactionTime.Block1, na.rm = TRUE)
  }
  if (is_empty(neutral_and_audio.visual1$ReactionTime.Block1) == TRUE) {
    DF$Correct_answers_neutral_and_audio.visual[i] = 0
  } else{
    DF$Correct_answers_neutral_and_audio.visual[i] <-
      length(neutral_and_audio.visual1$Answers.Block1)
  }
  DF$missed_answers_neutral_and_audio.visual[i] <- length(myData$Answer.Codes.Block1[myData$Answer.Codes.Block1 == 0 & myData$Presented.Condition.Block1 == "Neutral" & myData$Distractor.Modality.Block1 == "audio visual"])

}
# A temporary data set to hold the information from the VR data, so we can reuse this loop for the PC files.
PC_not_done <- DF

```

```{r long format for PC}
# to keep track of our 73 participants, we will assign them a ID number per participant.
ID <- c(10103, 10106, 10107, 10108, 10110, 10113, 10114, 10116, 10117, 10123, 10124, 10126, 10127, 10128, 10129, 10131, 10133, 10134, 10136, 10137, 10138, 10139, 10153, 10154, 10156, 10157, 10158, 20002, 20003, 20005, 20006, 20008, 20009, 20020, 20021, 20022, 30002, 30003, 30004, 30006, 30009, 30010, 30012, 30013, 30019, 30020, 30022, 30023, 30024, 30025, 30026, 30027, 30028, 30030, 30032, 30033, 30034, 30035, 30036, 30040, 30042, 30044, 30046, 30048, 30049, 30051, 30052, 30053, 30054, 30055, 30058, 30060, 30061)

PC_not_done$id <- ID
VR_not_done$id <- ID

#_______________PC___________________________#
# create a empty data frame that's empty ready to fill it up
LONG_PC_DATA <- data.frame(
  id = character(),
  stimuli_type = character(),
  stimuli_compatibility = character(),
  RT = numeric(),
  RT_sd = numeric(),
  RT_md = numeric(),
  corrects = numeric(),
  missed = numeric(),
  stringsAsFactors = FALSE
)

# set up a loop thats take every ID and execute the loop.
unique_ID <- unique(PC_not_done$id)
for (i in seq_along(unique_ID)) {
  # filter the data frame to get the rows for the current participant
  participant_data <- filter(PC_not_done, id == unique_ID[i])
  ID <- participant_data$id
  
  #Extract Incongruent Audio Data
  # extract RT mean
  RT <- participant_data$incongruent_and_audio_RT
  # extract RT sd
  RT_sd <- participant_data$incongruent_and_audio_RT_sd
  # extract RT md
  RT_md <- participant_data$incongruent_and_audio_RT_md
  # extract corrects
  corrects <- participant_data$Correct_answers_incongruent_and_audio
  # extract missed
  missed <- participant_data$missed_answers_incongruent_and_audio
  # define the stimuli type
  stimuli_type <- "audio"
  # define the stimuli compatibility
  stimuli_compatibility <- "incongruent"
  # add the new row to the data frame
  LONG_PC_DATA <-
    rbind(LONG_PC_DATA,
          data.frame(ID, stimuli_type, stimuli_compatibility, RT, RT_sd, RT_md, corrects, missed))
  rm(RT, RT_sd, RT_md, corrects, missed, stimuli_type, stimuli_compatibility) #clear objects before new variables are put in 
  
  #Extract Incongruent Visual Data
  # extract RT
  RT <- participant_data$incongruent_and_visual_RT
   # extract RT_sd
  RT_sd <- participant_data$incongruent_and_visual_RT_sd
  # extract RT_md
  RT_md <- participant_data$incongruent_and_visual_RT_md
  # extract corrects
  corrects <-participant_data$Correct_answers_incongruent_and_visual
    # extract missed
  missed <- participant_data$missed_answers_incongruent_and_visual
  # define the stimuli type
  stimuli_type <- "visual"
  # define the stimuli compatibility
  stimuli_compatibility <- "incongruent"
  # add the new row to the data frame
  LONG_PC_DATA <-
    rbind(LONG_PC_DATA,
          data.frame(ID, stimuli_type, stimuli_compatibility, RT, RT_sd, RT_md, corrects, missed))
  rm(RT, RT_sd, RT_md, corrects, missed, stimuli_type, stimuli_compatibility) #clear objects before new variables are put in 
  
  #Extract Incongruent Audio Visual Data
  # extract RT
  RT <- participant_data$incongruent_and_audio.visual_RT
  # extract RT_sd
  RT_sd <- participant_data$incongruent_and_audio.visual_RT_sd
  # extract RT_md
  RT_md <- participant_data$incongruent_and_audio.visual_RT_md
  # extract corrects
  corrects <- participant_data$Correct_answers_incongruent_and_audio.visual
  # extract missed
  missed <- participant_data$missed_answers_incongruent_and_audio.visual
  # define the stimuli type
  stimuli_type <- "audio.visual"
  # define the stimuli compatibility
  stimuli_compatibility <- "incongruent"
  # add the new row to the data frame
  LONG_PC_DATA <-
    rbind(LONG_PC_DATA,
          data.frame(ID, stimuli_type, stimuli_compatibility, RT, RT_sd, RT_md, corrects, missed))
  rm(RT, RT_sd, RT_md, corrects, missed, stimuli_type, stimuli_compatibility) #clear objects before new variables are put in 
  
  
  #Extract Congruent Audio Data
  # extract RT
  RT <- participant_data$congruent_and_audio_RT
  # extract RT_sd
  RT_sd <- participant_data$congruent_and_audio_RT_sd
  # extract RT_md
  RT_md <- participant_data$congruent_and_audio_RT_md
  # define the ID
  ID <- participant_data$id
  # extract corrects
  corrects <- participant_data$Correct_answers_congruent_and_audio
  # extract missed
  missed <- participant_data$missed_answers_congruent_and_audio
  # define the stimuli type
  stimuli_type <- "audio"
  # define the stimuli compatibility
  stimuli_compatibility <- "congruent"
  # add the new row to the data frame
  LONG_PC_DATA <-
    rbind(LONG_PC_DATA,
          data.frame(ID, stimuli_type, stimuli_compatibility, RT, RT_sd, RT_md, corrects, missed))
  rm(RT, RT_sd, RT_md, corrects, missed, stimuli_type, stimuli_compatibility) #clear objects before new variables are put in 
  
  # Extract Congruent Visual Data
  # extract RT
  RT <- participant_data$congruent_and_visual_RT
  # extract RT_sd
  RT_sd <- participant_data$congruent_and_visual_RT_sd
  # extract RT_md
  RT_md <- participant_data$congruent_and_visual_RT_md
  # extract corrects
  corrects <- participant_data$Correct_answers_congruent_and_visual
  # extract missed
  missed <- participant_data$missed_answers_congruent_and_visual
  # define the stimuli type
  stimuli_type <- "visual"
  # define the stimuli compatibility
  stimuli_compatibility <- "congruent"
  # add the new row to the data frame
  LONG_PC_DATA <-
    rbind(LONG_PC_DATA,
          data.frame(ID, stimuli_type, stimuli_compatibility, RT, RT_sd, RT_md, corrects, missed))
  rm(RT, RT_sd, RT_md, corrects, missed, stimuli_type, stimuli_compatibility) #clear objects before new variables are put in 
  
  #Extract Congruent Audio Visual Data
  # extract RT
  RT <- participant_data$congruent_and_audio.visual_RT
  # extract RT_sd
  RT_sd <- participant_data$congruent_and_audio.visual_RT_sd
  # extract RT_md
  RT_md <- participant_data$congruent_and_audio.visual_RT_md
  # extract corrects
  corrects <- participant_data$Correct_answers_congruent_and_audio.visual
  # extract missed
  missed <- participant_data$missed_answers_congruent_and_audio.visual
  # define the stimuli type
  stimuli_type <- "audio.visual"
  # define the stimuli compatibility
  stimuli_compatibility <- "congruent"
  # add the new row to the data frame
  LONG_PC_DATA <-
    rbind(LONG_PC_DATA,
          data.frame(ID, stimuli_type, stimuli_compatibility, RT, RT_sd, RT_md, corrects, missed))
  rm(RT, RT_sd, RT_md, corrects, missed, stimuli_type, stimuli_compatibility) #clear objects before new variables are put in 
  
  #Exytact Neutral Audio Data
  # extract RT
  RT <- participant_data$neutral_and_audio_RT
  # extract RT_sd
  RT_sd <- participant_data$neutral_and_audio_RT_sd
  # extract RT_md
  RT_md <- participant_data$neutral_and_audio_RT_md
  # extract corrects
  corrects <- participant_data$Correct_answers_neutral_and_audio
  # extract missed
  missed <- participant_data$missed_answers_neutral_and_audio
  # define the stimuli type
  stimuli_type <- "audio"
  # define the stimuli compatibility
  stimuli_compatibility <- "neutral"
  # add the new row to the data frame
  LONG_PC_DATA <-
    rbind(LONG_PC_DATA,
          data.frame(ID, stimuli_type, stimuli_compatibility, RT, RT_sd, RT_md, corrects, missed))
  rm(RT, RT_sd, RT_md, corrects, missed, stimuli_type, stimuli_compatibility) #clear objects before new variables are put in 
  
  #Extract Neutral Visual Data
  # extract RT
  RT <- participant_data$neutral_and_visual_RT
  # extract RT_sd
  RT_sd <- participant_data$neutral_and_visual_RT_sd
  # extract RT_md
  RT_md <- participant_data$neutral_and_visual_RT_md
  # extract corrects
  corrects <- participant_data$Correct_answers_neutral_and_visual
  # extract missed
  missed <- participant_data$missed_answers_neutral_and_visual
  # define the stimuli type
  stimuli_type <- "visual"
  # define the stimuli compatibility
  stimuli_compatibility <- "neutral"
  # add the new row to the data frame
  LONG_PC_DATA <-
    rbind(LONG_PC_DATA,
          data.frame(ID, stimuli_type, stimuli_compatibility, RT, RT_sd, RT_md, corrects, missed))
  rm(RT, RT_sd, RT_md, corrects, missed, stimuli_type, stimuli_compatibility) #clear objects before new variables are put in 
  
  #Extract Neutral Audio Visual
  # extract RT
  RT <- participant_data$neutral_and_audio.visual_RT
  # extract RT_sd
  RT_sd <- participant_data$neutral_and_audio.visual_RT_sd
  # extract RT_md
  RT_md <- participant_data$neutral_and_audio.visual_RT_md
  # extract corrects
  corrects <- participant_data$Correct_answers_neutral_and_audio.visual
  # extract missed
  missed <- participant_data$missed_answers_neutral_and_audio.visual
  # define the stimuli type
  stimuli_type <- "audio.visual"
  # define the stimuli compatibility
  stimuli_compatibility <- "neutral"
  # add the new row to the data frame
  LONG_PC_DATA <-
    rbind(LONG_PC_DATA,
          data.frame(ID, stimuli_type, stimuli_compatibility, RT, RT_sd, RT_md, corrects, missed))
  rm(RT, RT_sd, RT_md, corrects, missed, stimuli_type, stimuli_compatibility, participant_data, ID) #clear objects before new variables are put in 
}

#Mark all rows as PC data
LONG_PC_DATA$condition <- "PC" 
```

```{r long format for VR}
#_______________VR___________________________
#Clear objects that will be re-used
rm(unique_ID)

# create a empty data frame that's empty ready to fill it up
LONG_VR_DATA <- data.frame(
  id = character(),
  stimuli_type = character(),
  stimuli_compatibility = character(),
  RT = numeric(),
  RT_sd = numeric(),
  RT_md = numeric(),
  corrects = numeric(),
  missed = numeric(),
  stringsAsFactors = FALSE
)

# set up a loop thats take every ID and execute the loop.
unique_ID <- unique(VR_not_done$id)
for (i in seq_along(unique_ID)) {
  # filter the data frame to get the rows for the current participant
  participant_data <- filter(VR_not_done, id == unique_ID[i])
  # define the ID
  ID <- participant_data$id
  
  #Extract Incongruent Audio Data
  # extract RT
  RT <- participant_data$incongruent_and_audio_RT
  # extract RT_sd
  RT_sd <- participant_data$incongruent_and_audio_RT_sd
  # extract RT_md
  RT_md <- participant_data$incongruent_and_audio_RT_md
  # extract corrects
  corrects <- participant_data$Correct_answers_incongruent_and_audio
  # extract missed
  missed <- participant_data$missed_answers_incongruent_and_audio
  # define the stimuli type
  stimuli_type <- "audio"
  # define the stimuli compatibility
  stimuli_compatibility <- "incongruent"
  # add the new row to the data frame
  LONG_VR_DATA <-
    rbind(LONG_VR_DATA,
          data.frame(ID, stimuli_type, stimuli_compatibility, RT, RT_sd, RT_md, corrects, missed))
  rm(RT, RT_sd, RT_md, corrects, missed, stimuli_type, stimuli_compatibility) #clear objects before new variables are put in 
  
  #Extract Incongruent Visual Data
  # extract RT
  RT <- participant_data$incongruent_and_visual_RT
  # extract RT_sd
  RT_sd <- participant_data$incongruent_and_visual_RT_sd
  # extract RT_md
  RT_md <- participant_data$incongruent_and_visual_RT_md
  # extract corrects
  corrects <- participant_data$Correct_answers_incongruent_and_visual
  # extract missed
  missed <- participant_data$missed_answers_incongruent_and_visual
  # define the stimuli type
  stimuli_type <- "visual"
  # define the stimuli compatibility
  stimuli_compatibility <- "incongruent"
  # add the new row to the data frame
  LONG_VR_DATA <-
    rbind(LONG_VR_DATA,
          data.frame(ID, stimuli_type, stimuli_compatibility, RT, RT_sd, RT_md, corrects, missed))
  rm(RT, RT_sd, RT_md, corrects, missed, stimuli_type, stimuli_compatibility) #clear objects before new variables are put in 
  
  # Extract Incongruent Audio Visual Data
  # extract RT
  RT <- participant_data$incongruent_and_audio.visual_RT
  # extract RT_sd
  RT_sd <- participant_data$incongruent_and_audio.visual_RT_sd
  # extract RT_md
  RT_md <- participant_data$incongruent_and_audio.visual_RT_md
  # extract corrects
  corrects <- participant_data$Correct_answers_incongruent_and_audio.visual
  # extract missed
  missed <- participant_data$missed_answers_incongruent_and_audio.visual
  # define the stimuli type
  stimuli_type <- "audio.visual"
  # define the stimuli compatibility
  stimuli_compatibility <- "incongruent"
  # add the new row to the data frame
  LONG_VR_DATA <-
    rbind(LONG_VR_DATA,
          data.frame(ID, stimuli_type, stimuli_compatibility, RT, RT_sd, RT_md, corrects, missed))
  rm(RT, RT_sd, RT_md, corrects, missed, stimuli_type, stimuli_compatibility) #clear objects before new variables are put in 
  
  #Extract Congruent Audio Data
  # extract RT
  RT <- participant_data$congruent_and_audio_RT
  # extract RT_sd
  RT_sd <- participant_data$congruent_and_audio_RT_sd
  # extract RT_md
  RT_md <- participant_data$congruent_and_audio_RT_md
  # extract corrects
  corrects <- participant_data$Correct_answers_congruent_and_audio
  # extract missed
  missed <- participant_data$missed_answers_congruent_and_audio
  # define the stimuli type
  stimuli_type <- "audio"
  # define the stimuli compatibility
  stimuli_compatibility <- "congruent"
  # add the new row to the data frame
  LONG_VR_DATA <-
    rbind(LONG_VR_DATA,
          data.frame(ID, stimuli_type, stimuli_compatibility, RT, RT_sd, RT_md, corrects, missed))
  rm(RT, RT_sd, RT_md, corrects, missed, stimuli_type, stimuli_compatibility) #clear objects before new variables are put in 
  
  #Extract Congruent Visual Data
  # extract RT
  RT <- participant_data$congruent_and_visual_RT
  # extract RT_sd
  RT_sd <- participant_data$congruent_and_visual_RT_sd
  # extract RT_sd
  RT_md <- participant_data$congruent_and_visual_RT_md
  # extract corrects
  corrects <- participant_data$Correct_answers_congruent_and_visual
  # extract missed
  missed <- participant_data$missed_answers_congruent_and_visual
  # define the stimuli type
  stimuli_type <- "visual"
  # define the stimuli compatibility
  stimuli_compatibility <- "congruent"
  # add the new row to the data frame
  LONG_VR_DATA <-
    rbind(LONG_VR_DATA,
          data.frame(ID, stimuli_type, stimuli_compatibility, RT, RT_sd, RT_md, corrects, missed))
  rm(RT, RT_sd, RT_md, corrects, missed, stimuli_type, stimuli_compatibility) #clear objects before new variables are put in 
  
  #Extract Congruent Audio Visual Data
  # extract RT
  RT <- participant_data$congruent_and_audio.visual_RT
  # extract RT_sd
  RT_sd <- participant_data$congruent_and_audio.visual_RT_sd
  # extract RT_md
  RT_md <- participant_data$congruent_and_audio.visual_RT_md
  # extract corrects
  corrects <- participant_data$Correct_answers_congruent_and_audio.visual
  # extract missed
  missed <- participant_data$missed_answers_congruent_and_audio.visual
  # define the stimuli type
  stimuli_type <- "audio.visual"
  # define the stimuli compatibility
  stimuli_compatibility <- "congruent"
  # add the new row to the data frame
  LONG_VR_DATA <-
    rbind(LONG_VR_DATA,
          data.frame(ID, stimuli_type, stimuli_compatibility, RT, RT_sd, RT_md, corrects, missed))
  rm(RT, RT_sd, RT_md, corrects, missed, stimuli_type, stimuli_compatibility) #clear objects before new variables are put in 
  
  #Extract Neutral Audio Data
  # extract RT
  RT <- participant_data$neutral_and_audio_RT
  # extract RT_sd
  RT_sd <- participant_data$neutral_and_audio_RT_sd
  # extract RT_md
  RT_md <- participant_data$neutral_and_audio_RT_md
  # extract corrects
  corrects <- participant_data$Correct_answers_neutral_and_audio
  # extract missed
  missed <- participant_data$missed_answers_neutral_and_audio
  # define the stimuli type
  stimuli_type <- "audio"
  # define the stimuli compatibility
  stimuli_compatibility <- "neutral"
  # add the new row to the data frame
  LONG_VR_DATA <-
    rbind(LONG_VR_DATA,
          data.frame(ID, stimuli_type, stimuli_compatibility, RT, RT_sd, RT_md, corrects, missed))
  rm(RT, RT_sd, RT_md, corrects, missed, stimuli_type, stimuli_compatibility) #clear objects before new variables are put in 
  
  #Extract Neutral Visual Data
  # extract RT
  RT <- participant_data$neutral_and_visual_RT
  # extract RT_sd
  RT_sd <- participant_data$neutral_and_visual_RT_sd
  # extract RT_md
  RT_md <- participant_data$neutral_and_visual_RT_md
  # extract corrects
  corrects <- participant_data$Correct_answers_neutral_and_visual
  # extract missed
  missed <- participant_data$missed_answers_neutral_and_visual
  # define the stimuli type
  stimuli_type <- "visual"
  # define the stimuli compatibility
  stimuli_compatibility <- "neutral"
  # add the new row to the data frame
  LONG_VR_DATA <-
    rbind(LONG_VR_DATA,
          data.frame(ID, stimuli_type, stimuli_compatibility, RT, RT_sd, RT_md, corrects, missed))
  rm(RT, RT_sd, RT_md, corrects, missed, stimuli_type, stimuli_compatibility) #clear objects before new variables are put in 
  
  #Extract Neutral Audio Visual Data
  # extract RT
  RT <- participant_data$neutral_and_audio.visual_RT
  # extract RT_sd
  RT_sd <- participant_data$neutral_and_audio.visual_RT_sd
  # extract RT_md
  RT_md <- participant_data$neutral_and_audio.visual_RT_md
  # extract corrects
  corrects <- participant_data$Correct_answers_neutral_and_audio.visual
  # extract missed
  missed <- participant_data$missed_answers_neutral_and_audio.visual
  # define the stimuli type
  stimuli_type <- "audio.visual"
  # define the stimuli compatibility
  stimuli_compatibility <- "neutral"
  # add the new row to the data frame
  LONG_VR_DATA <-
    rbind(LONG_VR_DATA,
          data.frame(ID, stimuli_type, stimuli_compatibility, RT, RT_sd, RT_md, corrects, missed))
  rm(RT, RT_sd, RT_md, corrects, missed, stimuli_type, stimuli_compatibility, participant_data, ID) #clear objects before new variables are put in 
}

LONG_VR_DATA$condition <- "VR"
```

```{r One Long Dataset}

# putting the two data sets together.
ATTENTION_base <- rbind(LONG_VR_DATA, LONG_PC_DATA)

#Clean the environment before analyses
rm(congruent_and_audio.visual1, congruent_and_audio1, congruent_and_visual1, incongruent_and_audio.visual1, incongruent_and_audio1, incongruent_and_visual1, neutral_and_audio.visual1, neutral_and_audio1, neutral_and_visual1, header, myList, unique_ID)

```

### Data Quality  
Reaction time data is very sensitive to biases and extreme values. Therefore it is important to ensure consistency in the calculation of RT values between different conditions.  
First we ensure that all conditions do not have great differences in the number of available trials and that a reasonable minimum number of trials per trial type (congruency x multisensory modality) and per condition (VR and PC) are retained. This will help us to ensure that the differences we observe are not too affected by different trial numbers. 
  
The ideal would be to keep 9 trials per trial type and condition because that would ensure at least 56% accuracy on each trial type but this is not going to leave us with too many participants. In fact, the numbers do not look great (the code below can be manipulated to check how many participants remain if we set the minimum number of trials to be higher or lower - line 1081)  
  
9 trials = 8 participants  
8 trials = 8 participants  
7 trials = 13 participants  
6 trials = 17 participants  
5 trials = 22 participants  
  
Additionally, we have to remove all participants with overall accuracy below 55% - this means 3 additional participants and we are only left with 19 in the end.

```{r Data Quality Exclusions}
#We have to keep a consistent number of trials between the different types and conditions  so let's keep it as minimum of 5 trials per participants
ATTENTION_trial_filt <- ATTENTION_base %>% filter(corrects >4)


# summarize the amount of children who did not get above 5 in a permutation. grouped by condition.
unique_ID <- unique(ATTENTION_base$ID)
ATTENTION_base %>%
  filter(ID %in% unique_ID) %>%
  group_by(condition) %>%
  summarize(num_ID_4_or_lower = n_distinct(ID[corrects <= 4]))
# figure out how many share ID number, so i can calculate the amount of children who did not make criteria in each con.
ATTENTION_base %>%
  filter(corrects <= 4) %>%
  group_by(ID) %>%
  filter("PC" %in% condition & "VR" %in% condition) %>%
  summarize(num_rows = n()) %>%
  summarize(num_shared_IDs = n())

#Now let's check how many participants have all trial types retained in both PC and VR after we filtered out the low numbers of correct trials 
#R will produce a vector with the number of trials types retained per person. 

unique_ID <- unique(ATTENTION_base$ID)

x <- numeric()

for (i in 1:length(unique_ID)){
  x <- append(x, length(ATTENTION_trial_filt$ID[ATTENTION_trial_filt$ID == unique_ID[i]]), after = length(x))
  
}

#How many participants have all 18 trial types (9 trial types per condition, VR & PC)
unique_ID_keep <- unique_ID[x == 18]


#Select only those participants who have all trial types
ATTENTION_ptts_filt <- ATTENTION_trial_filt %>% filter(ID %in% unique_ID_keep)


# Now check how many participants reached 55% by chance results on the overall task 
# Produce a separate vector for VR and PC

VR <- numeric()
PC <- numeric()

#This is code that can be used to calculate accuracy excluding missed responses
#for (i in 1:length(unique_ID_keep)){
#  VR <- append(VR, sum(ATTENTION_ptts_filt$corrects[ATTENTION_ptts_filt$ID == unique_ID_keep[i] & ATTENTION_ptts_filt$condition == "VR"])/(144-sum(ATTENTION_ptts_filt$missed[ATTENTION_ptts_filt$ID == unique_ID_keep[i] & ATTENTION_ptts_filt$condition == "VR"]))*100, after = length(VR))
#}

for (i in 1:length(unique_ID_keep)){
  VR <- append(VR, (sum(ATTENTION_ptts_filt$corrects[ATTENTION_ptts_filt$ID == unique_ID_keep[i] & ATTENTION_ptts_filt$condition == "VR"])/144)*100, after = length(VR))
  
}

#This is code that can be used to calculate accuracy excluding missed responses
#for (i in 1:length(unique_ID_keep)){
#  PC <- append(PC, sum(ATTENTION_ptts_filt$corrects[ATTENTION_ptts_filt$ID == unique_ID_keep[i] & ATTENTION_ptts_filt$condition == "PC"])/(144-sum(ATTENTION_ptts_filt$missed[ATTENTION_ptts_filt$ID == unique_ID_keep[i] & ATTENTION_ptts_filt$condition == "PC"]))*100, after = length(PC))
#}

for (i in 1:length(unique_ID_keep)){
  PC <- append(PC, (sum(ATTENTION_ptts_filt$corrects[ATTENTION_ptts_filt$ID == unique_ID_keep[i] & ATTENTION_ptts_filt$condition == "PC"])/144)*100, after = length(PC))
  
}

#Print Participant IDs that should be removed 
# PC
unique_ID_keep[PC < 55]

#VR
unique_ID_keep[VR < 55]

#Create a new ID vector to keep

to_exclude <- unique(c(unique_ID_keep[PC < 55], unique_ID_keep[VR < 55]))


ATTENTION <- filter(ATTENTION_ptts_filt, !(ID %in% (to_exclude)))

# overview of the amount of participant left 
length(unique(ATTENTION$ID))



```


```{r distribution and variance tjek}
# We are plotting the quantile-quantile plots to ensure normal distribution of the data. We decided not to use the Shapiro-Wilk test due to its sensitivity to large sample sizes.
ggqqplot(ATTENTION, "RT", ggtheme = theme_bw()) +
  facet_grid(stimuli_type ~ condition  ~ stimuli_compatibility)

ggqqplot(ATTENTION, "corrects", ggtheme = theme_bw()) +
  facet_grid(stimuli_type ~ condition  ~ stimuli_compatibility)
# We are using the Levene's test to check for differences in variance between the two groups. This is to ensure that the assumption of homogeneity of variance is met.
ATTENTION %>%
  group_by(stimuli_compatibility , stimuli_type) %>%
  levene_test(RT ~ condition)

ATTENTION %>%
  group_by(stimuli_compatibility , stimuli_type) %>%
  levene_test(corrects ~ condition)
```

```{r calculate and add cost and benefit values to the data set}
# Create a vector with the desired values
cb_values <- rep(c("cost", "cost", "cost", "benefit", "benefit", "benefit", "", "", ""), length.out = nrow(data))

# Add the vector as a new column to the data set
ATTENTION$cost_benefit <- cb_values

ATTENTION <-
  data.frame(ATTENTION, cost_ben_val = rep(NA, nrow(ATTENTION)))


# Get unique IDs
unique_ids <- unique(ATTENTION$ID)
# Iterate over unique IDs
for (i in unique_ids) {
  # Subset data for current ID
  data <- subset(ATTENTION, ID == i)
  
  #___________________VR______________#
  # define the cost value, (incongruent - neutral trials) for the same stimuli type (audio)
  cost <- data[1, "RT_md"] - data[7, "RT_md"]
  # Find the first NA value in the 'cost_ben_val' column
  first_na <- which(is.na(ATTENTION$cost_ben_val))[1]
  
  # Assign the 'cost' value to the first NA in the 'cost_ben_val' column
  ATTENTION$cost_ben_val[first_na] <- cost
  
  # define the cost value, (incongruent - neutral trials) for the same stimuli type (visual)
  cost <- data[2, "RT_md"] - data[8, "RT_md"]
  # Find the first NA value in the 'cost_ben_val' column
  first_na <- which(is.na(ATTENTION$cost_ben_val))[1]
  
  # Assign the 'cost' value to the first NA in the 'cost_ben_val' column
  ATTENTION$cost_ben_val[first_na] <- cost
  
  # define the cost value, (incongruent - neutral trials) for the same stimuli type (audio.visual)
  cost <- data[3, "RT_md"] - data[9, "RT_md"]
  # Find the first NA value in the 'cost_ben_val' column
  first_na <- which(is.na(ATTENTION$cost_ben_val))[1]
  # Assign the 'cost' value to the first NA in the 'cost_ben_val' column
  ATTENTION$cost_ben_val[first_na] <- cost
  
  
  
  # define the benefit value, (neutral trials - congruent ) for the same stimuli type (audio)
  benefit <- data[7, "RT_md"]  - data[4, "RT_md"]
  # Find the first NA value in the 'cost_ben_val' column
  first_na <- which(is.na(ATTENTION$cost_ben_val))[1]
  
  # Assign the 'benefit' value to the first NA in the 'cost_ben_val' column
  ATTENTION$cost_ben_val[first_na] <- benefit
  
  # define the benefit value, ( neutral trials - congreunt ) for the same stimuli type (visual)
  benefit <-  data[8, "RT_md"] - data[5, "RT_md"]
  # Find the first NA value in the 'cost_ben_val' column
  first_na <- which(is.na(ATTENTION$cost_ben_val))[1]
  
  # Assign the 'benefit' value to the first NA in the 'cost_ben_val' column
  ATTENTION$cost_ben_val[first_na] <- benefit
  
  # define the benefit value, (neutral trials - congreunt) for the same stimuli type (audio.visual)
  benefit <- data[9, "RT_md"] - data[6, "RT_md"]
  # Find the first NA value in the 'cost_ben_val' column
  first_na <- which(is.na(ATTENTION$cost_ben_val))[1]
  # Assign the 'benefit' value to the first NA in the 'cost_ben_val' column
  ATTENTION$cost_ben_val[first_na] <- benefit
  
  
  # neutral
  # sett the next three equal to NA due to neutral - neutral is 0   neutral <- "NA"
  neutral <- "NEUTRAL"
  first_na <- which(is.na(ATTENTION$cost_ben_val))[1]
  
  # Assign the 'benefit' value to the first NA in the 'cost_ben_val' column
  ATTENTION$cost_ben_val[first_na] <- neutral
  
  # neutral
  # sett the next three equal to NA due to neutral - neutral is 0   neutral <- "NA"
  neutral <- "NEUTRAL"
  first_na <- which(is.na(ATTENTION$cost_ben_val))[1]
  
  # Assign the 'benefit' value to the first NA in the 'cost_ben_val' column
  ATTENTION$cost_ben_val[first_na] <- neutral
  
  # neutral
  # sett the next three equal to NA due to neutral - neutral is 0   neutral <- "NA"
  neutral <- "NEUTRAL"
  first_na <- which(is.na(ATTENTION$cost_ben_val))[1]
  
  # Assign the 'benefit' value to the first NA in the 'cost_ben_val' column
  ATTENTION$cost_ben_val[first_na] <- neutral
  
  
  
  #___________________PC______________#
  # define the cost value, (incongruent - neutral trials) for the same stimuli type (audio)
  cost <- data[10, "RT_md"] - data[16, "RT_md"]
  # Find the first NA value in the 'cost_ben_val' column
  first_na <- which(is.na(ATTENTION$cost_ben_val))[1]
  
  # Assign the 'cost' value to the first NA in the 'cost_ben_val' column
  ATTENTION$cost_ben_val[first_na] <- cost
  
  # define the cost value, (incongruent - neutral trials) for the same stimuli type (visual)
  cost <- data[11, "RT_md"] - data[17, "RT_md"]
  # Find the first NA value in the 'cost_ben_val' column
  first_na <- which(is.na(ATTENTION$cost_ben_val))[1]
  
  # Assign the 'cost' value to the first NA in the 'cost_ben_val' column
  ATTENTION$cost_ben_val[first_na] <- cost
  
  # define the cost value, (incongruent - neutral trials) for the same stimuli type (audio.visual)
  cost <- data[12, "RT_md"] - data[18, "RT_md"]
  # Find the first NA value in the 'cost_ben_val' column
  first_na <- which(is.na(ATTENTION$cost_ben_val))[1]
  # Assign the 'cost' value to the first NA in the 'cost_ben_val' column
  ATTENTION$cost_ben_val[first_na] <- cost
  
  
  # define the benefit value, (neutral trials - congruent ) for the same stimuli type (audio)
  benefit <- data[16, "RT_md"]  - data[13, "RT_md"]
  # Find the first NA value in the 'cost_ben_val' column
  first_na <- which(is.na(ATTENTION$cost_ben_val))[1]
  
  # Assign the 'benefit' value to the first NA in the 'cost_ben_val' column
  ATTENTION$cost_ben_val[first_na] <- benefit
  
  # define the benefit value, ( neutral trials - congreunt ) for the same stimuli type (visual)
  benefit <-  data[17, "RT_md"] - data[14, "RT_md"]
  # Find the first NA value in the 'cost_ben_val' column
  first_na <- which(is.na(ATTENTION$cost_ben_val))[1]
  
  # Assign the 'benefit' value to the first NA in the 'cost_ben_val' column
  ATTENTION$cost_ben_val[first_na] <- benefit
  
  # define the benefit value, (neutral trials - congreunt) for the same stimuli type (audio.visual)
  benefit <- data[18, "RT_md"] - data[15, "RT_md"]
  # Find the first NA value in the 'cost_ben_val' column
  first_na <- which(is.na(ATTENTION$cost_ben_val))[1]
  # Assign the 'benefit' value to the first NA in the 'cost_ben_val' column
  ATTENTION$cost_ben_val[first_na] <- benefit
  
  # neutral
  # sett the next three equal to NA due to neutral - neutral is 0   neutral <- "NA"
  neutral <- "NEUTRAL"
  first_na <- which(is.na(ATTENTION$cost_ben_val))[1]
  
  # Assign the 'benefit' value to the first NA in the 'cost_ben_val' column
  ATTENTION$cost_ben_val[first_na] <- neutral
  
  # neutral
  # sett the next three equal to NA due to neutral - neutral is 0   neutral <- "NA"
  neutral <- "NEUTRAL"
  first_na <- which(is.na(ATTENTION$cost_ben_val))[1]
  
  # Assign the 'benefit' value to the first NA in the 'cost_ben_val' column
  ATTENTION$cost_ben_val[first_na] <- neutral
  
  # neutral
  # sett the next three equal to NA due to neutral - neutral is 0   neutral <- "NA"
  neutral <- "NEUTRAL"
  first_na <- which(is.na(ATTENTION$cost_ben_val))[1]
  
  # Assign the 'benefit' value to the first NA in the 'cost_ben_val' column
  ATTENTION$cost_ben_val[first_na] <- neutral
  
}

# ConveRT_md the 'cost_ben_val' column of the 'ATTENTION' dataframe to numeric data type
ATTENTION$cost_ben_val <- as.numeric(ATTENTION$cost_ben_val)

# Group the 'ATTENTION' dataframe by 'condition', 'stimuli_type', and 'cost_benefit' columns and
# calculate summary statistics (mean and standard deviation) for the 'cost benefit values' column
ATTENTION %>%
  group_by(condition, stimuli_type , cost_benefit) %>%
  get_summary_stats(cost_ben_val, type = "mean_sd")

# remove all objects except for mydata and mylist
rm(list = setdiff(ls(), c("ATTENTION")))

```

```{r cost benefit statistics}
# group the data by both "cost_benefit" and "stimuli_type" and perform a paired t-test on the "cost benefit value"
# Next, we compare the condition and adjust the p-values using the Bonferroni correction.
# this was done to find diffrences between the conditions. based on the stimuli type.
ATTENTION %>%
  filter(!is.na(cost_ben_val)) %>%
  group_by(cost_benefit, stimuli_type) %>%
  t_test(cost_ben_val ~ condition ,
         p.adjust.method = "bonferroni",
         paired = T)

# group the data by both condition and cost benefit. and perform a paried t-test, on the cost benefit value.
# corrected with bonferoni.
# this was done to chek for in condition diffrences between the stimuly type
ATTENTION %>%
  filter(!is.na(cost_ben_val)) %>%
  group_by(cost_benefit, condition) %>%
  t_test(cost_ben_val ~ stimuli_type ,
         p.adjust.method = "bonferroni",
         paired = T)

# Additionally, we calculate the means and standard deviations of cost benefit results for each combination of "cost_benefit" and "stimuli_type".
# 
my_colors <- c("#0072B2", "#D55E00")
summary_stats <- ATTENTION %>%
  group_by(condition,cost_benefit,stimuli_type ) %>%
  get_summary_stats(cost_ben_val, type = "mean_sd")
  
ggplot(summary_stats, aes(x = stimuli_type, y = mean, fill = cost_benefit)) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~condition) +
  scale_fill_manual(values = my_colors) +
  labs(x = "Stimuli Type", y = "search time difffrence", fill = "cost/benefit")


```

```{r stattistics}
# statistics
# all permutations and between condition
ATTENTION %>%
  group_by(stimuli_type,stimuli_compatibility) %>%
  t_test(RT_md ~ condition,
         p.adjust.method = "bonferroni",
         paired = T)

ATTENTION %>%
  group_by(stimuli_type, stimuli_compatibility, condition) %>%
  get_summary_stats(RT_md, type = "mean_sd")
# simple overall t test to see the performance.
ATTENTION %>% 
  t_test(RT_md ~ condition,
         p.adjust.method = "bonferroni",
         paired = T)

ATTENTION %>%
  group_by(condition) %>%
  get_summary_stats(RT_md, type = "mean_sd")


# within stim type
view(ATTENTION %>%
  group_by(condition) %>%
  t_test(RT_md ~stimuli_type ,
         p.adjust.method = "bonferroni",
         paired = T))
ATTENTION %>%
  group_by(condition,stimuli_type) %>%
  get_summary_stats(RT_md, type = "mean_sd")


# within con compatibility
ATTENTION %>%
  group_by(condition) %>%
  t_test(RT_md ~stimuli_compatibility ,
         p.adjust.method = "bonferroni",
         paired = T)
ATTENTION %>%
  group_by(condition,stimuli_compatibility) %>%
  get_summary_stats(RT_md, type = "mean_sd")

```


```{r plots }
ggplot(ATTENTION, aes(x = stimuli_type, y = RT_md, fill = stimuli_compatibility)) +
  geom_violin(aes(color = stimuli_compatibility), trim = FALSE) + 
  geom_jitter(aes(color = stimuli_compatibility), position = position_jitter(0.7), alpha = 0.6) + 
  facet_wrap(~condition) +
  labs(x = "Stimuli Type", y = "Search Time", color = "Stimuli Compatibility") +
  theme_bw() +
  guides(fill = FALSE) +
  scale_color_manual(values = c("#0072B2", "#E69F00", "#009E73")) +
  scale_fill_manual(values = c("#0072B2", "#E69F00", "#009E73")) +
  theme(legend.position = "bottom", legend.title = element_text(face = "bold"), 
        panel.spacing.x = unit(0.5, "cm"))

RT



# Calculate the mean RT for each combination of stimuli type, compatibility, and condition
mean_RT <- aggregate(RT_md ~ stimuli_type + stimuli_compatibility + condition, data = ATTENTION, mean)
# Define custom color palette
my_colors <- c("#0072B2", "#E69F00", "#009E73", "#F0E442")
# Create the plot
ggplot(mean_RT, aes(x = stimuli_type, y = RT_md, fill = stimuli_compatibility)) +
  geom_bar(stat = "identity", position = position_dodge(), alpha = 0.8) + 
  facet_wrap(~condition) +
  labs(x = "Stimuli Type", y = "Mean search time", fill = "Stimuli Compatibility") +
  theme_bw() + # Set the theme to black and white
  guides(fill = guide_legend(nrow = 2, byrow = TRUE, title.position = "top", title.hjust = 0.5,
                              keywidth = unit(1, "cm"), keyheight = unit(0.5, "cm"),
                              label.position = "right", label.hjust = 0, label.vjust = 0.5,
                              label.theme = element_text(size = 8),
                              reverse = TRUE)) + # Add the legend with custom formatting
  scale_fill_manual(values = my_colors) # Set the custom colors for the legend


## for my presentation: rather than the violin .> 
mean_RT <- aggregate(RT_md ~ stimuli_type + stimuli_compatibility + condition, data = ATTENTION, mean)
# Define the colors for each condition
my_colors <- c("#0072B2", "#D55E00")
# Create the plot with fill based on condition
ggplot(mean_RT, aes(x = stimuli_type, y = RT_md, fill = condition)) +
  geom_bar(stat = "identity", position = position_dodge(), alpha = 0.8) + 
  facet_wrap(~stimuli_compatibility) +
  labs(x = "Stimuli Type", y = "Mean RT", fill = "Stimuli Compatibility")  + # Set the theme to black and white
  guides(fill = guide_legend(title = "Condition", title.position = "top")) + # Add legend with title on top
  scale_fill_manual(values = my_colors) + theme_bw()




my_colors <- c("#0072B2", "#D55E00")
# Create the plot with fill based on condition and facet by condition
ggplot(mean_RT, aes(x = stimuli_type, y = RT_md, fill = condition)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  labs(x = "Stimuli Type", y = "mean search time", fill = "Stimuli Compatibility") +
  scale_fill_manual(values = my_colors) + 
  facet_grid(. ~ condition, scales = "free") + # facet by condition
  theme_bw()





```

```{r Response Time Coefficient of Variability (RTCV)}
# The Response Time Coefficient of Variability (RTCV) is a measure of the variability in response times for a given task or stimulus. It is calculated as the ratio of the standard deviation of response times to the mean response time, expressed as a percentage.
# The formula for calculating RTCV is:
# RTCV = (standard deviation of response times / mean response time) x 100%
# A higher RTCV indicates that response times are more variable or inconsistent, while a lower RTCV indicates more consistent or predictable response times.

RTCV_table <- ATTENTION %>%
  group_by(condition, stimuli_type) %>%
  get_summary_stats(RT, type = "mean_sd") %>%
  mutate(RTCV = sd / mean * 100)

RTCV_table_total <- ATTENTION %>%
  group_by(condition) %>%
  get_summary_stats(RT, type = "mean_sd") %>%
  mutate(RTCV = sd / mean * 100)

RTCV_table
RTCV_table_total
```
